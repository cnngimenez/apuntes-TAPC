<!doctype html>
<html lang="es">
<head>
<title>Apuntes</title>
<!-- 2020-11-04 mié 12:05 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="generator" content="Org-mode">
<meta name="author" content="Christian Gimenez">
<link href="libs/bootstrap.min.css" rel="stylesheet">
<link href="css/style-org.css" rel="stylesheet">
<script src="libs/jquery.min.js"></script>
<script src="libs/bootstrap.min.js"></script>
<meta name="description" content="Apuntes del curso de Tópicos Avanzados en Programación Concurrente. ">
<meta name="keywords" content="Concurrencia, Paralelismo, Semáforos, Thread, Hilos">
<style>
/* org mode styles on top of twbs */

html {
    position: relative;
    min-height: 100%;
}

body {
    font-size: 18px;
    margin-bottom: 105px;
}

footer {
    position: absolute;
    bottom: 0;
    width: 100%;
    height: 101px;
    background-color: #f5f5f5;
}

footer > div {
    padding: 10px;
}

footer p {
    margin: 0 0 5px;
    text-align: center;
    font-size: 16px;
}

#table-of-contents {
    margin-top: 20px;
    margin-bottom: 20px;
}

blockquote p {
    font-size: 18px;
}

pre {
    font-size: 16px;
}

.footpara {
    display: inline-block;
}

figcaption {
  font-size: 16px;
  color: #666;
  font-style: italic;
  padding-bottom: 15px;
}

/* from twbs docs */

.bs-docs-sidebar.affix {
    position: static;
}
@media (min-width: 768px) {
    .bs-docs-sidebar {
        padding-left: 20px;
    }
}

/* All levels of nav */
.bs-docs-sidebar .nav > li > a {
    display: block;
    padding: 4px 20px;
    font-size: 14px;
    font-weight: 500;
    color: #999;
}
.bs-docs-sidebar .nav > li > a:hover,
.bs-docs-sidebar .nav > li > a:focus {
    padding-left: 19px;
    color: #A1283B;
    text-decoration: none;
    background-color: transparent;
    border-left: 1px solid #A1283B;
}
.bs-docs-sidebar .nav > .active > a,
.bs-docs-sidebar .nav > .active:hover > a,
.bs-docs-sidebar .nav > .active:focus > a {
    padding-left: 18px;
    font-weight: bold;
    color: #A1283B;
    background-color: transparent;
    border-left: 2px solid #A1283B;
}

/* Nav: second level (shown on .active) */
.bs-docs-sidebar .nav .nav {
    display: none; /* Hide by default, but at >768px, show it */
    padding-bottom: 10px;
}
.bs-docs-sidebar .nav .nav > li > a {
    padding-top: 1px;
    padding-bottom: 1px;
    padding-left: 30px;
    font-size: 12px;
    font-weight: normal;
}
.bs-docs-sidebar .nav .nav > li > a:hover,
.bs-docs-sidebar .nav .nav > li > a:focus {
    padding-left: 29px;
}
.bs-docs-sidebar .nav .nav > .active > a,
.bs-docs-sidebar .nav .nav > .active:hover > a,
.bs-docs-sidebar .nav .nav > .active:focus > a {
    padding-left: 28px;
    font-weight: 500;
}

/* Nav: third level (shown on .active) */
.bs-docs-sidebar .nav .nav .nav {
    padding-bottom: 10px;
}
.bs-docs-sidebar .nav .nav .nav > li > a {
    padding-top: 1px;
    padding-bottom: 1px;
    padding-left: 40px;
    font-size: 12px;
    font-weight: normal;
}
.bs-docs-sidebar .nav .nav .nav > li > a:hover,
.bs-docs-sidebar .nav .nav .nav > li > a:focus {
    padding-left: 39px;
}
.bs-docs-sidebar .nav .nav .nav > .active > a,
.bs-docs-sidebar .nav .nav .nav > .active:hover > a,
.bs-docs-sidebar .nav .nav .nav > .active:focus > a {
    padding-left: 38px;
    font-weight: 500;
}

/* Show and affix the side nav when space allows it */
@media (min-width: 992px) {
    .bs-docs-sidebar .nav > .active > ul {
        display: block;
    }
    /* Widen the fixed sidebar */
    .bs-docs-sidebar.affix,
    .bs-docs-sidebar.affix-bottom {
        width: 213px;
    }
    .bs-docs-sidebar.affix {
        position: fixed; /* Undo the static from mobile first approach */
        top: 20px;
    }
    .bs-docs-sidebar.affix-bottom {
        position: absolute; /* Undo the static from mobile first approach */
    }
    .bs-docs-sidebar.affix .bs-docs-sidenav,.bs-docs-sidebar.affix-bottom .bs-docs-sidenav {
        margin-top: 0;
        margin-bottom: 0
    }
}
@media (min-width: 1200px) {
    /* Widen the fixed sidebar again */
    .bs-docs-sidebar.affix-bottom,
    .bs-docs-sidebar.affix {
        width: 263px;
    }
}
</style>
<script>
$(function() {
    'use strict';

    $('.bs-docs-sidebar li').first().addClass('active');

    $(document.body).scrollspy({target: '.bs-docs-sidebar'});

    $('.bs-docs-sidebar').affix();
});
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="index.html"> UP </a>
 |
 <a accesskey="H" href="index.html"> HOME </a>
</div><div id="content" class="container">
<div class="row"><div class="col-md-3 col-md-push-9"><nav id="table-of-contents">
<div id="text-table-of-contents" class="bs-docs-sidebar">
<ul class="nav">
<li><a href="#sec-1">1. Concurrencia</a>
<ul class="nav">
<li><a href="#sec-1-1">1.1. Procesos</a></li>
<li><a href="#sec-1-2">1.2. Hilos de ejecución (threads)</a></li>
</ul>
</li>
<li><a href="#sec-2">2. Características</a>
<ul class="nav">
<li><a href="#sec-2-1">2.1. Competición</a>
<ul class="nav">
<li><a href="#sec-2-1-1">2.1.1. Deadlock</a></li>
<li><a href="#sec-2-1-2">2.1.2. Starvation</a></li>
</ul>
</li>
<li><a href="#sec-2-2">2.2. Cooperación</a></li>
</ul>
</li>
<li><a href="#sec-3">3. Propiedades</a>
<ul class="nav">
<li><a href="#sec-3-1">3.1. Seguridad y de vida</a>
<ul class="nav">
<li><a href="#sec-3-1-1">3.1.1. Livelock</a></li>
<li><a href="#sec-3-1-2">3.1.2. Viveza</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-4">4. Hilos</a>
<ul class="nav">
<li><a href="#sec-4-1">4.1. Estados</a>
<ul class="nav">
<li><a href="#sec-4-1-1">4.1.1. Creado</a></li>
<li><a href="#sec-4-1-2">4.1.2. Listo</a></li>
<li><a href="#sec-4-1-3">4.1.3. En ejecución</a></li>
<li><a href="#sec-4-1-4">4.1.4. Bloqueado</a></li>
<li><a href="#sec-4-1-5">4.1.5. Terminado</a></li>
</ul>
</li>
<li><a href="#sec-4-2">4.2. Métodos</a></li>
<li><a href="#sec-4-3">4.3. Propiedades y características</a>
<ul class="nav">
<li><a href="#sec-4-3-1">4.3.1. Seguridad / safety</a></li>
<li><a href="#sec-4-3-2">4.3.2. Viveza / liveness</a></li>
<li><a href="#sec-4-3-3">4.3.3. Características de PC</a></li>
</ul>
</li>
<li><a href="#sec-4-4">4.4. Inconsistencia</a>
<ul class="nav">
<li><a href="#sec-4-4-1">4.4.1. Condición de carrera</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-5">5. Problema de sincronización</a>
<ul class="nav">
<li><a href="#sec-5-1">5.1. Sección crítica</a>
<ul class="nav">
<li><a href="#sec-5-1-1">5.1.1. Uso de la sección crítica</a></li>
<li><a href="#sec-5-1-2">5.1.2. Debe Cumplir</a></li>
<li><a href="#sec-5-1-3">5.1.3. Mecanismos</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-6">6. Problemas clásicos</a>
<ul class="nav">
<li><a href="#sec-6-1">6.1. Hilos que no hacen nada</a>
<ul class="nav">
<li><a href="#sec-6-1-1">6.1.1. Implementación</a></li>
</ul>
</li>
<li><a href="#sec-6-2">6.2. Filósofos cenando</a>
<ul class="nav">
<li><a href="#sec-6-2-1">6.2.1. Solución</a></li>
</ul>
</li>
<li><a href="#sec-6-3">6.3. Barbero dormilón - rendez-vous</a>
<ul class="nav">
<li><a href="#sec-6-3-1">6.3.1. Solución</a></li>
</ul>
</li>
<li><a href="#sec-6-4">6.4. Productor-consumidor</a>
<ul class="nav">
<li><a href="#sec-6-4-1">6.4.1. Problema sin sincronización</a></li>
<li><a href="#sec-6-4-2">6.4.2. Solución con semáforos</a></li>
</ul>
</li>
<li><a href="#sec-6-5">6.5. Lectores-escritores</a></li>
<li><a href="#sec-6-6">6.6. Cocinero-comensal</a></li>
<li><a href="#sec-6-7">6.7. Fumadores</a>
<ul class="nav">
<li><a href="#sec-6-7-1">6.7.1. Solución</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-7">7. Hilos en los lenguajes de programación</a>
<ul class="nav">
<li><a href="#sec-7-1">7.1. Ada</a></li>
<li><a href="#sec-7-2">7.2. Python</a>
<ul class="nav">
<li><a href="#sec-7-2-1">7.2.1. Threads</a></li>
<li><a href="#sec-7-2-2">7.2.2. Coroutines and tasks</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</nav>
</div><div class="col-md-9 col-md-pull-3"><h1 class="title">Apuntes</h1>
<p>
El siguiente es un apunte escrito para el curso <i>Tópicos Avanzados en Programación Concurrente</i>. 
</p>

<ul class="org-ul">
<li>Fuentes de este apunte: <a href="https://github.com/cnngimenez/apuntes-TAPC">Repositorio de Github</a>
</li>
<li>Códigos extraídos (<i>tangled</i>) de este documento se encuentran en el directorio <code>tangled/*</code> de este repositorio.
</li>
</ul>


<figure>
<p><img src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" class="img-responsive" alt="88x31.png">
</p>
</figure>

<p>
This work is licensed under a <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.
</p>

<p>
Este obra está bajo una <a href="http://creativecommons.org/licenses/by-sa/4.0/">licencia de Creative Commons Reconocimiento-CompartirIgual 4.0 Internacional</a>.
</p>


<p>
Para compilar los códigos de Ada 2012 se requiere del compilador GNAT y la utilidad gprbuild. La siguiente secuencia de comandos permite generar los binarios:
</p>

<pre class="example">
cd tangled/ada
gprbuild tapc.gpr -p
</pre>


<p>
Luego, los binarios se pueden encontrar en la carpeta <code>tangled/ada/bin</code> y se ejecutan de la forma convencional:
</p>

<pre class="example">
bin/producer_consumer
</pre>



<figure>
<p><img src="imgs/1.overview.png" class="img-responsive" alt="1.overview.png">
</p>
</figure>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Concurrencia</h2>
<div class="outline-text-2" id="text-1">
<p>
Dos tareas activas al mismo tiempo. 
</p>

<p>
Con o sin soporte multitarea del hardware (paralelismo exige soporte de hardware).
</p>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> Procesos</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Una actividad de concurrente.
</p>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> Hilos de ejecución (threads)</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Trabajar con muchos hilos no necesariamente aumenta la eficiencia de la ejecución proporcionalmente.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Características</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> Competición</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Pelearse por un recurso.
</p>
</div>
<div id="outline-container-sec-2-1-1" class="outline-4">
<h4 id="sec-2-1-1"><span class="section-number-4">2.1.1</span> Deadlock</h4>
<div class="outline-text-4" id="text-2-1-1">
<p>
Trabarse entre sí.
</p>
</div>
</div>
<div id="outline-container-sec-2-1-2" class="outline-4">
<h4 id="sec-2-1-2"><span class="section-number-4">2.1.2</span> Starvation</h4>
<div class="outline-text-4" id="text-2-1-2">
<p>
Un proceso nunca puede llegar a completarse.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> Cooperación</h3>
<div class="outline-text-3" id="text-2-2">
<ul class="org-ul">
<li>Trabajan de forma independiente.
</li>
<li>En algún momento se sincronizan y cooperan.
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Propiedades</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> Seguridad y de vida</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Un programa hace lo que fue pensado o diseñado.
</p>

<ul class="org-ul">
<li>Dos procesos no pueden mezclarse.
</li>
<li>Se requiere una <b>exclusión mutua</b> para no mezclar los recursos.
</li>
</ul>
</div>

<div id="outline-container-sec-3-1-1" class="outline-4">
<h4 id="sec-3-1-1"><span class="section-number-4">3.1.1</span> Livelock</h4>
<div class="outline-text-4" id="text-3-1-1">
<p>
Cuando los procesos no concuerdan al compartir información o estado.
</p>
</div>
</div>

<div id="outline-container-sec-3-1-2" class="outline-4">
<h4 id="sec-3-1-2"><span class="section-number-4">3.1.2</span> Viveza</h4>
<div class="outline-text-4" id="text-3-1-2">
<ul class="org-ul">
<li>Justicia : Un proceso que puede ser ejecutado, va a ser ejecutado. Que todos los procesos reciban un tiempo de ejecución de manera justa.
</li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Hilos</h2>
<div class="outline-text-2" id="text-4">
<p>
Un hilo está activo cuando está "con vida" en el sistema. O sea que está en un estado: listo, en ejecución, bloqueado.
</p>
</div>

<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> Estados</h3>
<div class="outline-text-3" id="text-4-1">

<figure>
<p><img src="imgs/2.estados.png" class="img-responsive" alt="2.estados.png">
</p>
</figure>
</div>


<div id="outline-container-sec-4-1-1" class="outline-4">
<h4 id="sec-4-1-1"><span class="section-number-4">4.1.1</span> Creado</h4>
</div>

<div id="outline-container-sec-4-1-2" class="outline-4">
<h4 id="sec-4-1-2"><span class="section-number-4">4.1.2</span> Listo</h4>
<div class="outline-text-4" id="text-4-1-2">
<p>
Cuando comienza. Scheduler indica cuándo pasar a ejecución.
</p>

<ul class="org-ul">
<li>Puede pasar a <b>ejecución</b>.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-4-1-3" class="outline-4">
<h4 id="sec-4-1-3"><span class="section-number-4">4.1.3</span> En ejecución</h4>
<div class="outline-text-4" id="text-4-1-3">
<p>
Las instrucciones se ejecuta en el CPU.
</p>

<ul class="org-ul">
<li>Cuando se bloquea pasa a <b>bloqueado</b>.
</li>
<li>Puede pasar a <b>listo</b>.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-4-1-4" class="outline-4">
<h4 id="sec-4-1-4"><span class="section-number-4">4.1.4</span> Bloqueado</h4>
<div class="outline-text-4" id="text-4-1-4">
<p>
Se bloquea debido a que requiere de un recurso.
</p>

<ul class="org-ul">
<li>Al desbloquearse pasa a <b>listo</b>.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-4-1-5" class="outline-4">
<h4 id="sec-4-1-5"><span class="section-number-4">4.1.5</span> Terminado</h4>
<div class="outline-text-4" id="text-4-1-5">
<p>
Puede ser por falla o porque no hay más instrucciones.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> Métodos</h3>
<div class="outline-text-3" id="text-4-2">
<ul class="org-ul">
<li>Start :
</li>
<li>Join :
</li>
<li>Sleep :
</li>
<li>Yield : Pasar a otro proceso.
</li>
<li>currentThread : <code>Runtime.getRuntime().availableProcesors()</code>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3"><span class="section-number-3">4.3</span> Propiedades y características</h3>
<div class="outline-text-3" id="text-4-3">
</div><div id="outline-container-sec-4-3-1" class="outline-4">
<h4 id="sec-4-3-1"><span class="section-number-4">4.3.1</span> Seguridad / safety</h4>
<div class="outline-text-4" id="text-4-3-1">
<p>
Un proceso es seguro cuando:
</p>
<ul class="org-ul">
<li>Se utiliza exclusión mutua
</li>
<li>Condición de sinc.
</li>
<li>Se evita el deadlock.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-3-2" class="outline-4">
<h4 id="sec-4-3-2"><span class="section-number-4">4.3.2</span> Viveza / liveness</h4>
<div class="outline-text-4" id="text-4-3-2">
<ul class="org-ul">
<li>Evitar inanición (que se quede en estado de Bloqueado siempre).
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-3-3" class="outline-4">
<h4 id="sec-4-3-3"><span class="section-number-4">4.3.3</span> Características de PC</h4>
<div class="outline-text-4" id="text-4-3-3">
<ul class="org-ul">
<li>Indeterminismo : No se puede asegurar la salida porque no se sabe cómo actuará la concurrencia (en qué orden se ejecutan primero o último).
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-4-4" class="outline-3">
<h3 id="sec-4-4"><span class="section-number-3">4.4</span> Inconsistencia</h3>
<div class="outline-text-3" id="text-4-4">
<p>
Lo siguiente puede suceder.
</p>
</div>

<div id="outline-container-sec-4-4-1" class="outline-4">
<h4 id="sec-4-4-1"><span class="section-number-4">4.4.1</span> Condición de carrera</h4>
<div class="outline-text-4" id="text-4-4-1">
<p>
Cuando se comparte un recurso (o variable) entre dos procesos.
</p>
</div>
</div>
</div>
</div>


<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Problema de sincronización</h2>
<div class="outline-text-2" id="text-5">
<p>
Para evitar la condición de carrera, el hilo se debe tomar el dato, modificarlo y después soltarlo.
</p>

<ul class="org-ul">
<li>mutex: exclusión mutua
</li>
<li>java usa syncronized.
</li>
</ul>

<p>
<code>syncronized</code> se utiliza tanto en la lectura y escritura del dato compartido.
</p>

<div class="org-src-container">

<pre class="src src-java"><span style="color: #81A1C1;">public</span> <span style="color: #81A1C1;">synchronized</span> <span style="color: #88C0D0;">getData</span>(){
}
<span style="color: #81A1C1;">public</span> <span style="color: #81A1C1;">synchronized</span> <span style="color: #88C0D0;">setData</span>(){
}
</pre>
</div>
</div>

<div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> Sección crítica</h3>
<div class="outline-text-3" id="text-5-1">
<p>
Se considera que el código de la sección crítica es una operación atómica. 
</p>
</div>

<div id="outline-container-sec-5-1-1" class="outline-4">
<h4 id="sec-5-1-1"><span class="section-number-4">5.1.1</span> Uso de la sección crítica</h4>
</div>


<div id="outline-container-sec-5-1-2" class="outline-4">
<h4 id="sec-5-1-2"><span class="section-number-4">5.1.2</span> Debe Cumplir</h4>
<div class="outline-text-4" id="text-5-1-2">
<ul class="org-ul">
<li>Exclusión mutua
</li>
<li>Progreso
</li>
<li>Espera limitada
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-5-1-3" class="outline-4">
<h4 id="sec-5-1-3"><span class="section-number-4">5.1.3</span> Mecanismos</h4>
<div class="outline-text-4" id="text-5-1-3">
</div><ol class="org-ol"><li><a id="sec-5-1-3-1" name="sec-5-1-3-1"></a>Semáforos<br ><div class="outline-text-5" id="text-5-1-3-1">
<p>
Existen binarios o generales.
</p>

<ul class="org-ul">
<li>Binario : Piden un permiso.
</li>
<li>General : Pueden pedir N permisos.
</li>
</ul>

<p>
Tiene dos operaciones (son atómicas):
</p>

<ul class="org-ul">
<li>Adquirir permiso :
<ul class="org-ul">
<li>Si el semáforo no es nulo, se puede adquirir el permiso.
</li>
<li>Si el semáforo es nulo, se suspende.
</li>
</ul>
</li>
<li>Liberar permiso
<ul class="org-ul">
<li>Si hay procesos suspendidos, activa uno.
</li>
</ul>
</li>
</ul>

<p>
El liberar puede liberar uno o más de uno dependiendo si el semáforo es general o binario.
</p>

<p>
Observar que tomar un permiso con <code>sem.aquire(1)</code> es más simple que <code>sem.aquire(4)</code>. Por lo que simularía daría prioridad a los hilos que usen un número menor de permisos.
</p>

<p>
Cuando un semáforo se libera el scheduler determina qué otro thread adquiere la ejecución y el semáforo.
</p>

<p>
Al utilizar varios semáforos o varios procesos a sincronizar, se torna difícil de entender y gestionar. Es mejor usar los semáforos cuando hay procesos que se sincronizan al estilo "primero uno y después el otro".
</p>

<p>
También, se puede utilizar semáforos para establecer un orden de ejecución o de precedencia de los procesos. 
</p>


<figure>
<p><img src="imgs/process.png" class="img-responsive" alt="process.png">
</p>
</figure>

<div class="org-src-container">

<pre class="src src-ada"><span style="color: #81A1C1;">procedure</span> P0 <span style="color: #81A1C1;">is</span>
<span style="color: #81A1C1;">begin</span>
    <span style="color: #616e88;">-- </span><span style="color: #616e88;">Hacer algo</span>
    Liberar (Sem0_1);
    Liberar (Sem0_2);
<span style="color: #81A1C1;">end</span> P0;

<span style="color: #81A1C1;">procedure</span> P1 <span style="color: #81A1C1;">is</span>
<span style="color: #81A1C1;">begin</span>
    <span style="color: #616e88;">-- </span><span style="color: #616e88;">Hacer algo</span>
    Liberar (Sem1_3);
<span style="color: #81A1C1;">end</span> P1;

<span style="color: #81A1C1;">procedure</span> P2 <span style="color: #81A1C1;">is</span>
<span style="color: #81A1C1;">begin</span>
    <span style="color: #616e88;">-- </span><span style="color: #616e88;">Hacer algo</span>
    Liberar (Sem2_3);
<span style="color: #81A1C1;">end</span> P2;
</pre>
</div>
</div>
</li>


<li><a id="sec-5-1-3-2" name="sec-5-1-3-2"></a>Monitores<br ><div class="outline-text-5" id="text-5-1-3-2">
<p>
Están en estrecha relación con POO y con un mayor nivel de abstracción. Es un recurso compartido (el dato) con métodos sincronizados. 
</p>

<p>
Usualmente, el monitor (el que posee los métodos sincronizados) es el objeto pasivo.
</p>

<ul class="org-ul">
<li>Los métodos con syncronized significa que se produce una exclusión mutua.
</li>
<li>Cada proceso tiene su lock.
</li>
<li><code>wait()</code> bloquea el proceso actual y libera para que el próximo proceso pueda utilizarse.
</li>
<li><code>notify(), notifyAll()</code>
</li>
</ul>
</div>

<ol class="org-ol"><li><a id="sec-5-1-3-2-1" name="sec-5-1-3-2-1"></a>Synchronized de Java<br ><div class="outline-text-6" id="text-5-1-3-2-1">
<p>
Un método declarado como <code>synchonized</code> tiene dos efectos:
</p>

<ul class="org-ul">
<li>No es posible que se produzcan dos invocaciones de méntodos synchronized de un mismo objeto al mismo tiempo.
</li>
<li>Establece una relación de "sucede-antes" con cualquier invocación subsecuente de un método de sincronización. En otras palabras, se establece un orden en la ejecución de los métodos. 
</li>
</ul>

<p>
En otras palabras, se previene la interferencia entre los hilos y la generación de inconsistencias. 
</p>

<p>
Se explica en la sección <a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/syncmeth.html">Syncronization de The Java(tm) Tutorials</a>.
</p>
</div>
</li></ol>
</li>

<li><a id="sec-5-1-3-3" name="sec-5-1-3-3"></a>Locks<br ></li></ol>
</div>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Problemas clásicos</h2>
<div class="outline-text-2" id="text-6">
<p>
En todos los modelos hay:
</p>

<ul class="org-ul">
<li>Objetos activos
</li>
<li>Objetos pasivos : Recursos que se comparten entre todos los objetos activos.
</li>
</ul>
</div>


<div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1"><span class="section-number-3">6.1</span> Hilos que no hacen nada</h3>
<div class="outline-text-3" id="text-6-1">
<ul class="org-ul">
<li>Objetos activos: Tareas/hilos
</li>
<li>Objetos pasivos: Ninguno
</li>
</ul>

<p>
Simplemente, son hilos o tareas que no realizan ninguna acción de importancia. Este problema se presenta aquí con la intención de mostrar cómo escribir tareas o probar el funcionamiento de los hilos.
</p>

<p>
También, es de utilidad para observar el funcionamiento del sistema operativo su forma de reconocer los hilos bajo cierto lenguaje. 
</p>

<p>
Considere utilizar algún mecanismo de señal para terminar el proceso: Control + C en sistemas basados en Unix o ejecutando <code>kill -9 ID_PROCESO</code>.
</p>
</div>

<div id="outline-container-sec-6-1-1" class="outline-4">
<h4 id="sec-6-1-1"><span class="section-number-4">6.1.1</span> <span class="label label-primary TODO">TODO</span> Implementación</h4>
<div class="outline-text-4" id="text-6-1-1">
</div>

<ol class="org-ol"><li><a id="sec-6-1-1-1" name="sec-6-1-1-1"></a>Bibliotecas necesarias<br ><div class="outline-text-5" id="text-6-1-1-1">
<p>
Las siguientes bibliotecas son necesarias para identificar la cantidad de CPUs, poder definir dominios de CPU, identificar cada una de las tareas y para imprimir en pantalla.
</p>

<p>
Luego, se puede comenzar con el programa principal.
</p>

<div class="org-src-container">

<pre class="src src-ada"><span style="color: #81A1C1;">with</span> System.Multiprocessors;
<span style="color: #81A1C1;">use</span> System.Multiprocessors;
<span style="color: #81A1C1;">with</span> System.Multiprocessors.Dispatching_Domains;
<span style="color: #81A1C1;">use</span> System.Multiprocessors.Dispatching_Domains;

<span style="color: #81A1C1;">with</span> Ada.Task_Identification;
<span style="color: #81A1C1;">use</span> Ada.Task_Identification;
<span style="color: #81A1C1;">with</span> Ada.Text_IO;
<span style="color: #81A1C1;">use</span> Ada.Text_IO;

<span style="color: #81A1C1;">procedure</span> Nothing_Tasks <span style="color: #81A1C1;">is</span>
</pre>
</div>
</div>
</li>

<li><a id="sec-6-1-1-2" name="sec-6-1-1-2"></a>La tarea<br ><div class="outline-text-5" id="text-6-1-1-2">
<p>
Se utilizará un solo tipo de tarea denominada <code>Nothing_Task</code>. Su declaración es sin entradas ni variables. Se comentan una serie de pragmas para asignarle la afinidad y la prioridad.
</p>

<div class="org-src-container">

<pre class="src src-ada"><span style="color: #81A1C1;">task</span> <span style="color: #81A1C1;">type</span> Nothing_Task <span style="color: #81A1C1;">is</span>
    <span style="color: #616e88;">--  </span><span style="color: #616e88;">Uncomment the following pragma tu run all tasks on the second CPU.</span>
    <span style="color: #616e88;">--  </span><span style="color: #616e88;">pragma CPU (2);</span>
    <span style="color: #616e88;">--  </span><span style="color: #616e88;">pragma Priority (2);</span>
    <span style="color: #616e88;">--  </span><span style="color: #616e88;">pragma Dispatching_Domain (The_Domain);</span>
<span style="color: #81A1C1;">end</span> Nothing_Task;
</pre>
</div>

<p>
La tarea solo realizará una asignación y una suma que es irrelevante.
</p>

<div class="org-src-container">

<pre class="src src-ada"><span style="color: #81A1C1;">task</span> <span style="color: #81A1C1;">body</span> Nothing_Task <span style="color: #81A1C1;">is</span>
    I : Positive;
<span style="color: #81A1C1;">begin</span>
    <span style="color: #81A1C1;">loop</span>
        <span style="color: #616e88;">--  </span><span style="color: #616e88;">Do just the same... nothing!</span>
        I := 1;
        I := I + 1;
    <span style="color: #81A1C1;">end</span> <span style="color: #81A1C1;">loop</span>;
<span style="color: #81A1C1;">end</span> Nothing_Task;
</pre>
</div>

<p>
A continuación, se crearán hasta un máximo de 10 tareas. Según el estándar de Ada, estas tareas serán distribuídas por los procesadores (ver <a href="http://www.ada-auth.org/standards/rm12_w_tc1/html/RM-D.html">Annex D "Real-Time Systems" en "Ada 2012 Reference Manual</a>")
</p>

<div class="org-src-container">

<pre class="src src-ada">Nothing : <span style="color: #81A1C1;">array</span> (1 .. 10) <span style="color: #81A1C1;">of</span> Nothing_Task;
</pre>
</div>
</div>
</li>

<li><a id="sec-6-1-1-3" name="sec-6-1-1-3"></a>Programa principal<br ><div class="outline-text-5" id="text-6-1-1-3">
<p>
El programa principal mostrará la cantidad de CPUs detectados y algunos datos identificatorios de las tareas. Observar que las tareas comenzarán su ejecución luego del <code>begin</code> del programa principal, por lo que no hay que llamar a ningún método de inicio como el <code>start()</code>.
</p>

<p>
Las tareas no tienen finalización y el programa no terminará hasta que todas sus tareas dependientes terminen. En otras palabras, el programa quedará en funcionamiento hasta que el usuario le indique al sistema operativo que detenga al proceso de forma forzada.
</p>

<div class="org-src-container">

<pre class="src src-ada"><span style="color: #81A1C1;">begin</span>
    Put_Line (<span style="color: #A3BE8C;">"Main thread"</span>);

    Put_Line (<span style="color: #A3BE8C;">"CPU detected: "</span>
                &amp; CPU'Image (Number_Of_CPUs));

    <span style="color: #81A1C1;">for</span> I <span style="color: #81A1C1;">of</span> Nothing <span style="color: #81A1C1;">loop</span>
        Put (<span style="color: #A3BE8C;">"Task "</span> &amp; Image (I'Identity) &amp; <span style="color: #A3BE8C;">": "</span>);
        <span style="color: #81A1C1;">if</span> Get_CPU (I'Identity) = Not_A_Specific_CPU <span style="color: #81A1C1;">then</span>
            Put_Line (<span style="color: #A3BE8C;">"CPU assigned: Not specified (0 value)"</span>);
        <span style="color: #81A1C1;">else</span>
            Put_Line (<span style="color: #A3BE8C;">"CPU assigned:"</span> &amp; CPU'Image (Get_CPU (I'Identity)));
        <span style="color: #81A1C1;">end</span> <span style="color: #81A1C1;">if</span>;
    <span style="color: #81A1C1;">end</span> <span style="color: #81A1C1;">loop</span>;

    Put_Line (<span style="color: #A3BE8C;">"End of main thread"</span>);
<span style="color: #81A1C1;">end</span> Nothing_Tasks;
</pre>
</div>
</div>
</li></ol>
</div>
</div>

<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2"><span class="section-number-3">6.2</span> Filósofos cenando</h3>
<div class="outline-text-3" id="text-6-2">
<ul class="org-ul">
<li>Objetos activos: Filósofos cenando/pensando.
</li>
<li>Objetos pasivos: tenedores (o palillos).
</li>
</ul>

<p>
Se puede utilizar el <code>tryAcquire()</code> de un semáforo para intentar adquirir un tenedor. Si está libre lo toma, sino lo deja.
</p>
</div>

<div id="outline-container-sec-6-2-1" class="outline-4">
<h4 id="sec-6-2-1"><span class="section-number-4">6.2.1</span> <span class="label label-primary TODO">TODO</span> Solución</h4>
</div>
</div>
<div id="outline-container-sec-6-3" class="outline-3">
<h3 id="sec-6-3"><span class="section-number-3">6.3</span> Barbero dormilón - rendez-vous</h3>
<div class="outline-text-3" id="text-6-3">
<ul class="org-ul">
<li>Objetos activos: Barbero, clientes.
</li>
<li>Objetos pasivos: corte, barba.
</li>

<li>El barbero se duerme si no hay clientes en espera
</li>
<li>Clientes despierta al barbero para atenderlo
</li>
<li>Barbero despierta al cliente al terminar de razurar
</li>
<li>Nuevos clientes esperan si el barbero está ocupado.
</li>
</ul>
</div>

<div id="outline-container-sec-6-3-1" class="outline-4">
<h4 id="sec-6-3-1"><span class="section-number-4">6.3.1</span> <span class="label label-primary TODO">TODO</span> Solución</h4>
</div>
</div>

<div id="outline-container-sec-6-4" class="outline-3">
<h3 id="sec-6-4"><span class="section-number-3">6.4</span> Productor-consumidor</h3>
<div class="outline-text-3" id="text-6-4">
<ul class="org-ul">
<li>Objetos activos: Productores y consumidores.
</li>
<li>Objectos pasivos: datos y buffer.
</li>
</ul>

<p>
Dos tipos de buffer (o de problemas Productor-Consumidor):
</p>
<ul class="org-ul">
<li>Buffer limitiado
</li>
<li>Buffer ilimitado
</li>
</ul>

<p>
Productor-consumidor con un buffer de tamaño 1 (de un solo dato) es muy poco utilizado.
</p>

<p>
Esquema:
</p>

<div class="org-src-container">

<pre class="src src-ada"><span style="color: #81A1C1;">task</span> <span style="color: #81A1C1;">body</span> Productor <span style="color: #81A1C1;">is</span>
<span style="color: #81A1C1;">begin</span>
    <span style="color: #81A1C1;">loop</span>
        Producir (Dato);
        Poner_Dato (Dato, Buffer);
        Liberar (dato_disponible);
    <span style="color: #81A1C1;">end</span> <span style="color: #81A1C1;">loop</span>;
<span style="color: #81A1C1;">end</span> Productor;
</pre>
</div>

<div class="org-src-container">

<pre class="src src-ada"><span style="color: #81A1C1;">task</span> <span style="color: #81A1C1;">body</span> Consumidor <span style="color: #81A1C1;">is</span>
<span style="color: #81A1C1;">begin</span>
    <span style="color: #81A1C1;">loop</span>
        dato := Sacar_Dato(Buffer);
        Cosumir (Dato);
    <span style="color: #81A1C1;">end</span> <span style="color: #81A1C1;">loop</span>;
<span style="color: #81A1C1;">end</span> Consumidor;
</pre>
</div>
</div>

<div id="outline-container-sec-6-4-1" class="outline-4">
<h4 id="sec-6-4-1"><span class="section-number-4">6.4.1</span> Problema sin sincronización</h4>
<div class="outline-text-4" id="text-6-4-1">
<p>
A continuación se detalla el código de productores consumidores con condición de carrera. 
</p>

<p>
El programa generará una cantidad determinada de productores y consumidores. Los productores generarán una cantidad máxima de números enteros, por ejemplo de 10000 a 0, sin repetir el número. Los consumidores retirarán este número del almacenamiento y lo reportarán a la salida estándar.
</p>
</div>

<ol class="org-ol"><li><a id="sec-6-4-1-1" name="sec-6-4-1-1"></a>Bibliotecas necesarias<br ><div class="outline-text-5" id="text-6-4-1-1">
<p>
Necesitaremos las siguientes biblietecas de Ada para poder almacenar datos dinámicamente e imprimir en pantalla:
</p>

<div class="org-src-container">

<pre class="src src-ada"><span style="color: #81A1C1;">with</span> Ada.Containers.Vectors;
<span style="color: #81A1C1;">with</span> Ada.Text_IO;
<span style="color: #81A1C1;">use</span> Ada.Text_IO;
</pre>
</div>

<p>
Luego se comenzará con el programa principal.
</p>

<div class="org-src-container">

<pre class="src src-ada"><span style="color: #81A1C1;">procedure</span> Producer_Consumer <span style="color: #81A1C1;">is</span>
</pre>
</div>
</div>
</li>

<li><a id="sec-6-4-1-2" name="sec-6-4-1-2"></a>Estructuras necesarias<br ><div class="outline-text-5" id="text-6-4-1-2">
<p>
Se requerirá un vector del dato que se quere producir y consumir. En este caso, el tipo de dato será entero. En Ada, el Vector es un paquete genérico donde se debe instanciar en un paquete usable definiendo el tipo de dato del elemento y del índice. 
</p>

<div class="org-src-container">

<pre class="src src-ada"><span style="color: #81A1C1;">package</span> Data_Vectors <span style="color: #81A1C1;">is</span> <span style="color: #81A1C1;">new</span> Ada.Containers.Vectors
  (Element_Type =&gt; Integer,
   Index_Type =&gt; Positive);
</pre>
</div>

<p>
Se requerirá dos tipos de tareas, uno para los consumidores y otro para los productores. Se declara una entrada para inicializarlas con un <code>Id</code> para identificarlas al momento de imprimir en pantalla. Además, se utilizará esta entrada para que las tareas al ser creadas esperen y no se ejecuten hasta que el programa principal les indique.
</p>

<div class="org-src-container">

<pre class="src src-ada"><span style="color: #81A1C1;">task</span> <span style="color: #81A1C1;">type</span> Consumer_Task <span style="color: #81A1C1;">is</span>
    <span style="color: #81A1C1;">entry</span> Initialize (The_Id : Integer);
<span style="color: #81A1C1;">end</span> Consumer_Task;

<span style="color: #81A1C1;">task</span> <span style="color: #81A1C1;">type</span> Producer_Task <span style="color: #81A1C1;">is</span>
    <span style="color: #81A1C1;">entry</span> Initialize (The_Id : Integer);
<span style="color: #81A1C1;">end</span> Producer_Task;
</pre>
</div>
</div>
</li>

<li><a id="sec-6-4-1-3" name="sec-6-4-1-3"></a>Datos disponibles<br ><div class="outline-text-5" id="text-6-4-1-3">
<p>
El programa principal y las tareas dispondrán de los siguientes datos: 
</p>

<ul class="org-ul">
<li>El máximo número de elementos a producir. Éste número es constante.
</li>
<li>Una instancia de <code>Data_Vectors.Vector</code> que almacenará los datos producidos.
</li>
<li>El número de dato actual que se está produciendo. Comenzará con el máximo e irá disminuyendo a medida que se produce un dato.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-ada">Maximum_Element : <span style="color: #81A1C1;">constant</span> Integer := 10000;
Data : Data_Vectors.Vector;
Current_Element : Integer := Maximum_Element;
</pre>
</div>
</div>
</li>

<li><a id="sec-6-4-1-4" name="sec-6-4-1-4"></a>Implementación del consumidor<br ><div class="outline-text-5" id="text-6-4-1-4">
<p>
La tarea para el consumidor requerirá de las siguientes variables locales: una variable temporal para retener el elemento a consumir y su id.
</p>

<div class="org-src-container">

<pre class="src src-ada"><span style="color: #81A1C1;">task</span> <span style="color: #81A1C1;">body</span> Consumer_Task <span style="color: #81A1C1;">is</span>
    Element : Integer;
    Id : Integer;
<span style="color: #81A1C1;">begin</span>
</pre>
</div>
</div>

<ol class="org-ol"><li><a id="sec-6-4-1-4-1" name="sec-6-4-1-4-1"></a>La inicialización del consumidor<br ><div class="outline-text-6" id="text-6-4-1-4-1">
<p>
Para inicializar simplemente se asignará el parámetro a la variable local y se reporta el inicio del consumidor en consola.
</p>

<p>
Cuando la tarea se crea, su ejecución comienza inmediatamente. Esta entrada está declarada como <code>accept</code> para que se bloquee hasta que reciba el mensaje <code>Initialize (The_Id: Integer)</code>. Al recibirlo, ejecutará el código de inicialización y continuará con la ejecución.
</p>

<div class="org-src-container">

<pre class="src src-ada"><span style="color: #81A1C1;">accept</span> Initialize (The_Id : Integer) <span style="color: #81A1C1;">do</span>
    Id := The_Id;
    Put_Line (<span style="color: #A3BE8C;">"T"</span> &amp; Id'Image &amp; <span style="color: #A3BE8C;">"&gt; Consumer initialized."</span>);
<span style="color: #81A1C1;">end</span> Initialize;
</pre>
</div>
</div>
</li>

<li><a id="sec-6-4-1-4-2" name="sec-6-4-1-4-2"></a>Consumir hasta el último elemento<br ><div class="outline-text-6" id="text-6-4-1-4-2">
<p>
La siguiente repetitiva retira un elemento del vector global y lo muestra en pantalla. Esto será realizado mientras que el último elemento producido sea mayor que cero.
</p>

<div class="org-src-container">

<pre class="src src-ada"><span style="color: #81A1C1;">while</span> Current_Element &gt; 0 <span style="color: #81A1C1;">loop</span>
    Element := Data.First_Element;
    Data.Delete_First;

    Put_Line (<span style="color: #A3BE8C;">"T"</span> &amp; Id'Image &amp; <span style="color: #A3BE8C;">"&gt; Consumed element:"</span>);
    Put_Line (<span style="color: #A3BE8C;">"    "</span> &amp; Element'Image);
<span style="color: #81A1C1;">end</span> <span style="color: #81A1C1;">loop</span>;
</pre>
</div>
</div>
</li>

<li><a id="sec-6-4-1-4-3" name="sec-6-4-1-4-3"></a>Fin del consumidor<br ><div class="outline-text-6" id="text-6-4-1-4-3">
<p>
Para identificar cuándo termina, se programará al consumidor para que escriba en la salida que ha concluido.
</p>

<div class="org-src-container">

<pre class="src src-ada">    Set_Colour (Green);
    Put_Line (<span style="color: #A3BE8C;">"T"</span> &amp; Id'Image &amp; <span style="color: #A3BE8C;">"&gt; Consumer ended."</span>);
    Default_Colour;

<span style="color: #81A1C1;">end</span> Consumer_Task;
</pre>
</div>
</div>
</li></ol>
</li>

<li><a id="sec-6-4-1-5" name="sec-6-4-1-5"></a>Implementación del productor<br ><div class="outline-text-5" id="text-6-4-1-5">
<p>
En el caso del productor, solo se necesita almacenar localmente el id de cada uno.
</p>

<div class="org-src-container">

<pre class="src src-ada"><span style="color: #81A1C1;">task</span> <span style="color: #81A1C1;">body</span> Producer_Task <span style="color: #81A1C1;">is</span>
    Id : Integer;
<span style="color: #81A1C1;">begin</span>
</pre>
</div>

<p>
La inicialización es análoga al consumidor.
</p>

<div class="org-src-container">

<pre class="src src-ada"><span style="color: #81A1C1;">accept</span> Initialize (The_Id : Integer) <span style="color: #81A1C1;">do</span>
    Id := The_Id;
    Put_Line (<span style="color: #A3BE8C;">"T"</span> &amp; Id'Image &amp; <span style="color: #A3BE8C;">"&gt; Producer initialized."</span>);
<span style="color: #81A1C1;">end</span> Initialize;
</pre>
</div>
</div>

<ol class="org-ol"><li><a id="sec-6-4-1-5-1" name="sec-6-4-1-5-1"></a>Producir hasta el último elemento<br ><div class="outline-text-6" id="text-6-4-1-5-1">
<p>
La siguiente repetitiva incorporará un dato entero dentro del Vector compartido con los consumidores. Luego, reportará qué elemento se produjo por terminal.
</p>

<p>
A medida que se van produciendo, el índice del elemento actual se reducirá en uno. Obsérvese que se crearán varios productores, por lo que se podría esperar que el índice será modificado por cada uno de ellos delegando la producción de uno o varios ítems a los distintos productores.
</p>

<div class="org-src-container">

<pre class="src src-ada"><span style="color: #81A1C1;">while</span> Current_Element &gt; 0 <span style="color: #81A1C1;">loop</span>
    Data.Append (Current_Element);

    Put_Line (<span style="color: #A3BE8C;">"T"</span> &amp; Id'Image &amp; <span style="color: #A3BE8C;">"&gt; Produced element:"</span>);
    Put_Line (<span style="color: #A3BE8C;">"    "</span> &amp; Current_Element'Image);

    Current_Element := Current_Element - 1;
<span style="color: #81A1C1;">end</span> <span style="color: #81A1C1;">loop</span>;
</pre>
</div>
</div>
</li>

<li><a id="sec-6-4-1-5-2" name="sec-6-4-1-5-2"></a>Fin del productor<br ><div class="outline-text-6" id="text-6-4-1-5-2">
<p>
Al terminar de producir todos los ítems, se reporta en la salida estándar que el productor concluyó con su tarea.
</p>

<div class="org-src-container">

<pre class="src src-ada">    Put_Line (<span style="color: #A3BE8C;">"T"</span> &amp; Id'Image &amp; <span style="color: #A3BE8C;">"&gt; Producer ended."</span>);

<span style="color: #81A1C1;">end</span> Producer_Task;
</pre>
</div>
</div>
</li></ol>
</li>

<li><a id="sec-6-4-1-6" name="sec-6-4-1-6"></a>Progama principal<br ><div class="outline-text-5" id="text-6-4-1-6">
<p>
La tarea de la tarea o programa principal es la de inicializar cada tarea y permitir su ejecución. 
</p>

<p>
Se requerirá crear y almacenar los productores y consumidores en un arreglo. Se crearán hasta 20 tareas de cada uno. La variable <code>I</code> será utilizada como índice para asignarles un identificador único a cada tarea.
</p>

<div class="org-src-container">

<pre class="src src-ada">    Producers : <span style="color: #81A1C1;">array</span> (1 .. 20) <span style="color: #81A1C1;">of</span> Producer_Task;
    Consumers : <span style="color: #81A1C1;">array</span> (1 .. 20) <span style="color: #81A1C1;">of</span> Consumer_Task;
    I : Integer := 0;

<span style="color: #81A1C1;">begin</span>
</pre>
</div>

<p>
Al llegar al <code>begin</code> del programa principal, las tareas comenzarán su ejecución. Sin embargo, todas se detendrán al encontrar  <code>accept Initialize (The_Id: Integer)</code> a la espera de dicho mensaje. 
</p>

<p>
Cabe aclarar que la inicialización es para asignarles a las tareas un identificador númerico fácil de leer. Sin embargo, no es necesario puesto que las tareas ya se ejecutan automáticamente y ya poseen un identificador asignado por el lenguaje Ada. En este caso se realiza como convención y para que las tareas esperen a ser iniciadas al mismo tiempo.
</p>

<p>
Por último, cuando la tarea principal se termine de ejecutar, el programa no se cerrará hasta que todas las tareas dependientes finalicen.
</p>

<p>
A continuación, se procede a inicializar las tareas con su para asignarles su Id numérico.
</p>

<div class="org-src-container">

<pre class="src src-ada">    Put_Line (<span style="color: #A3BE8C;">"Main thread"</span>);

    <span style="color: #81A1C1;">for</span> Producer <span style="color: #81A1C1;">of</span> Producers <span style="color: #81A1C1;">loop</span>
        Producer.Initialize (I);
        I := I + 1;
    <span style="color: #81A1C1;">end</span> <span style="color: #81A1C1;">loop</span>;

    <span style="color: #81A1C1;">for</span> Consumer <span style="color: #81A1C1;">of</span> Consumers <span style="color: #81A1C1;">loop</span>
        Consumer.Initialize (I);
        I := I + 1;
    <span style="color: #81A1C1;">end</span> <span style="color: #81A1C1;">loop</span>;

    Put_Line (<span style="color: #A3BE8C;">"End of main thread"</span>);
<span style="color: #81A1C1;">end</span> Producer_Consumer;
</pre>
</div>
</div>
</li>

<li><a id="sec-6-4-1-7" name="sec-6-4-1-7"></a>Mejoras: afinidad, prioridad y dominio de CPU<br ><div class="outline-text-5" id="text-6-4-1-7">
<p>
Al declarar las tareas se puede indicar la afinidad, en otras palabras, en qué CPU se debe ejecutar, la prioridad de cada tarea y el dominio del CPU.
</p>

<p>
El dominio de CPU permite agrupar los CPU en dominios y asignarles a las tareas dicho dominio. O sea, repartir ciertas tareas a un grupo de CPUs.
</p>

<p>
Para más información, ver el estándar de Ada en el anexo D.16: <a href="arm2012#D.16">Info manual: Ada Reference Manual, Anexo D.16</a> ó en la Web visitar <a href="http://www.ada-auth.org/standards/rm12_w_tc1/html/RM-D-16.html">Ada Conformity Assesment Authority, Ada Reference Manual, Annex D.16 Multiprocessor Implementation</a>.
</p>
</div>
</li></ol>
</div>

<div id="outline-container-sec-6-4-2" class="outline-4">
<h4 id="sec-6-4-2"><span class="section-number-4">6.4.2</span> Solución con semáforos</h4>
<div class="outline-text-4" id="text-6-4-2">
<p>
Esta solución usará tres tipos de tareas: una cosumidora, una productora y una contadora. El rol de la tarea contadora es registrar cuantos consumidores han finalizado y mostrar la cantidad de datos sin consumir cuando no hayan tareas que consuma. Mostrar esta cantidad al terminar cada hilo podría producir una condición de carrera. Tampoco serviría mostrar la cantidad al finalizar el programa principal puesto que es porbable que sea el primer hilo que termine antes que los productores y consumidores.
</p>
</div>

<ol class="org-ol"><li><a id="sec-6-4-2-1" name="sec-6-4-2-1"></a>Bibliotecas necesarias<br ><div class="outline-text-5" id="text-6-4-2-1">
<p>
Se necesitan bibliotecas para almacenar los datos producidos, imprimir en pantalla y utilizar semáforos.
</p>

<p>
La biblioteca de semáforos es parte de la implementación GNAT y no del estándar (por ello, no se encuentra incluido dentro del paquete Ada). En Ada se define otro tipo de sincronización basado en mensajes mutuamente excluyentes dejando el resto de los mecanismos para implementar.
</p>

<div class="org-src-container">

<pre class="src src-ada"><span style="color: #81A1C1;">with</span> Ada.Containers.Vectors;
<span style="color: #81A1C1;">with</span> Ada.Text_IO;
<span style="color: #81A1C1;">use</span> Ada.Text_IO;
<span style="color: #81A1C1;">with</span> GNAT.Semaphores;
<span style="color: #81A1C1;">use</span> GNAT.Semaphores;

<span style="color: #81A1C1;">procedure</span> Producer_Consumer_Semaphore <span style="color: #81A1C1;">is</span>
</pre>
</div>
</div>
</li>

<li><a id="sec-6-4-2-2" name="sec-6-4-2-2"></a>Datos y elementos necesarios<br ><div class="outline-text-5" id="text-6-4-2-2">
<p>
Se definirán dos constantes: la cantidad de consumidores y productores a crear. También se necesitará la cantidad máxima de datos a producir.
</p>

<div class="org-src-container">

<pre class="src src-ada">Consumers_Count : <span style="color: #81A1C1;">constant</span> Positive := 20;
Producers_Count : <span style="color: #81A1C1;">constant</span> Positive := 20;
Maximum_Element : <span style="color: #81A1C1;">constant</span> Integer := 10000;
</pre>
</div>

<p>
Luego, se definirán los semáforos. <code>Data_Semaphore</code> mantendrá la exclusión mutua al momento de utilizar los datos producidos y <code>Current_Element_Semaphore</code> evitará la condición de carrera de la variable que indica el siguiente elemento a producir.
</p>

<p>
Se utilizarán los dos tipos de semáforos: El binario y el no binario. Para crear una instancia de cada tipo se debe indicar el valor inicial de cada semáforo.
</p>

<div class="org-src-container">

<pre class="src src-ada">Data_Semaphore : Counting_Semaphore
  (Initial_Value =&gt; 0,
  Ceiling =&gt; Default_Ceiling);
Current_Element_Semaphore : Binary_Semaphore
  (Initially_Available =&gt; True,
   Ceiling =&gt; Default_Ceiling);
</pre>
</div>

<p>
La variable <code>Data</code> será utilizada para guardar los datos a consumir. Será un vector con elementos de tipo Integer e índice de tipo Positive. Recordar que el paquete <code>Ada.Containers.Vectors</code> es genérico por lo que se debe crear un paquete instancia de éste.
</p>

<div class="org-src-container">

<pre class="src src-ada"><span style="color: #81A1C1;">package</span> Data_Vectors <span style="color: #81A1C1;">is</span> <span style="color: #81A1C1;">new</span> Ada.Containers.Vectors
  (Element_Type =&gt; Integer,
   Index_Type =&gt; Positive);

Data : Data_Vectors.Vector;
</pre>
</div>

<p>
La variable <code>Current_Element</code> indicará el elemento a producirse. Cada productor consultará esta variable y la decrementará en uno al momento de crear un dato. Iniciará con el máximo valor posible.
</p>

<div class="org-src-container">

<pre class="src src-data">Current_Element : Integer := Maximum_Element;
</pre>
</div>
</div>
</li>

<li><a id="sec-6-4-2-3" name="sec-6-4-2-3"></a>Declaración de las tareas<br ><div class="outline-text-5" id="text-6-4-2-3">
<p>
Se requerirán tres tareas: Los consumidores, los productores y una tarea que contará cada consumidor que finaliza.
</p>

<p>
Las tareas consumidores y productores definirán una entrada llamada <code>Initialize</code> que será utilizada para brindarles un identificador. La tarea contadora define una entrada <code>Add_Consumer (Id : Integer)</code>, que será el mensaje enviado por el consumidor previo a terminar.
</p>

<div class="org-src-container">

<pre class="src src-ada"><span style="color: #81A1C1;">task</span> <span style="color: #81A1C1;">type</span> Consumer_Task <span style="color: #81A1C1;">is</span>
    <span style="color: #616e88;">--  </span><span style="color: #616e88;">Give an ID to the Task instance.</span>
    <span style="color: #81A1C1;">entry</span> Initialize (The_Id : Integer);
<span style="color: #81A1C1;">end</span> Consumer_Task;

<span style="color: #81A1C1;">task</span> <span style="color: #81A1C1;">type</span> Producer_Task <span style="color: #81A1C1;">is</span>
    <span style="color: #616e88;">--  </span><span style="color: #616e88;">Give an ID to the Task instance.</span>
    <span style="color: #81A1C1;">entry</span> Initialize (The_Id : Integer);
<span style="color: #81A1C1;">end</span> Producer_Task;

<span style="color: #81A1C1;">task</span> <span style="color: #81A1C1;">type</span> Count_Task <span style="color: #81A1C1;">is</span>
    <span style="color: #81A1C1;">entry</span> Add_Consumer (Id : Integer);
<span style="color: #81A1C1;">end</span> Count_Task;
</pre>
</div>
</div>
</li>

<li><a id="sec-6-4-2-4" name="sec-6-4-2-4"></a>Implementación de las tareas<br ><div class="outline-text-5" id="text-6-4-2-4">
<p>
Previo a la implementación de las tareas, es necesario crear la tarea contadora. Es preciso definir la variable que la contendrá aquí para poder hacerle referencia dentro de la implementación de los consumidores.
</p>

<div class="org-src-container">

<pre class="src src-ada">Counter : Count_Task;
</pre>
</div>
</div>

<ol class="org-ol"><li><a id="sec-6-4-2-4-1" name="sec-6-4-2-4-1"></a>Tarea consumidor<br ><div class="outline-text-6" id="text-6-4-2-4-1">
<p>
La tarea consumidor necesita de dos variables: una para guardar el elemento a consumir y otra para preservar su identificador. También se definirán dos procedimientos privados: El procedimiento para consumir el elemento y otro para mostrar un string en pantalla con el Id de la tarea.
</p>

<div class="org-src-container">

<pre class="src src-ada"><span style="color: #81A1C1;">task</span> <span style="color: #81A1C1;">body</span> Consumer_Task <span style="color: #81A1C1;">is</span>
    Element : Integer;
    Id : Integer;

    <span style="color: #81A1C1;">procedure</span> Consume_Element;
    <span style="color: #81A1C1;">procedure</span> Show (S : String);

    <span style="color: #81A1C1;">procedure</span> Consume_Element <span style="color: #81A1C1;">is</span>
    <span style="color: #81A1C1;">begin</span>
        Element := Data.First_Element;
        Data.Delete_First;

        Show (<span style="color: #A3BE8C;">"Consumed element:"</span> &amp; Element'Image);
    <span style="color: #81A1C1;">end</span> Consume_Element;

    <span style="color: #81A1C1;">procedure</span> Show (S : String) <span style="color: #81A1C1;">is</span>
    <span style="color: #81A1C1;">begin</span>
        Put_Line (<span style="color: #A3BE8C;">"C"</span> &amp; Id'Image &amp; <span style="color: #A3BE8C;">"&gt; "</span> &amp; S);
    <span style="color: #81A1C1;">end</span> Show;
<span style="color: #81A1C1;">begin</span>
</pre>
</div>

<p>
Al comenzar, el consumidor espera por el mensaje <code>Initialize</code> para recibir su identificador. Apenas lo recibe, muestra que inicia su trabajo.
</p>

<div class="org-src-container">

<pre class="src src-ada"><span style="color: #81A1C1;">accept</span> Initialize (The_Id : Integer) <span style="color: #81A1C1;">do</span>
    Id := The_Id;
    Show (<span style="color: #A3BE8C;">"Consumer initialized."</span>);
<span style="color: #81A1C1;">end</span> Initialize;
</pre>
</div>

<p>
Luego, comienza el bucle esperando por un dato. Utiliza el semáforo para esperar por el dato. Cuando un productor haya terminado de producir, el semáforo se libera permitiendo a un consumidor continuar.
</p>

<div class="org-src-container">

<pre class="src src-ada"><span style="color: #81A1C1;">loop</span>
    Data_Semaphore.Seize;
</pre>
</div>

<p>
Inmediatamente, el consumidor se vuelve a bloquear esperando utilizar la variable <code>Current_Element</code> con la intención de ver si su trabajo terminó. El consumidor termina su actividad cuando encuentra que resta un dato por cada hilo por consumir. Apenas termina de utilizar la variable, libera el semáforo correspondiente. La instrucción <code>exit when ...</code> permite salir del bucle cuando la condición indicada se cumple.
</p>

<div class="org-src-container">

<pre class="src src-ada">Current_Element_Semaphore.Seize;
<span style="color: #81A1C1;">exit</span> <span style="color: #81A1C1;">when</span> Current_Element &lt;= Consumers_Count <span style="color: #81A1C1;">and</span> <span style="color: #81A1C1;">then</span>
  Natural (Data.Length) &lt;= Consumers_Count;
Current_Element_Semaphore.Release;
</pre>
</div>

<p>
A continuación, consume el elemento y libera el semáforo de los datos.
</p>

<div class="org-src-container">

<pre class="src src-ada">    Consume_Element;
    Data_Semaphore.Release;
<span style="color: #81A1C1;">end</span> <span style="color: #81A1C1;">loop</span>;
</pre>
</div>

<p>
Los últimos pasos del consumidor consiste en liberar el semáforo de <code>Current_Element</code> que fue adquirido previo a salir del bucle (previo a la instrucción <code>exit when ...</code> Luego, consumir el elemento que falta y declarar a la tarea contadora que su trabajo terminó.
</p>

<p>
Considerar que al salir del bucle, ya se produjeron casi todos los datos y solo resta un dato por cada hilo consumidor. 
</p>

<div class="org-src-container">

<pre class="src src-ada">    Current_Element_Semaphore.Release;

    Consume_Element;

    Counter.Add_Consumer (Id);
    Show (<span style="color: #A3BE8C;">"Consumer ended."</span>);
<span style="color: #81A1C1;">end</span> Consumer_Task;
</pre>
</div>
</div>
</li>

<li><a id="sec-6-4-2-4-2" name="sec-6-4-2-4-2"></a>Tarea contador<br ><div class="outline-text-6" id="text-6-4-2-4-2">
<p>
El contador solo necesita una variable local que es la que mantiene el número de consumidores registrados. Como solo se utilizará una sola tarea, no hacen falta semáforos.
</p>

<div class="org-src-container">

<pre class="src src-ada"><span style="color: #81A1C1;">task</span> <span style="color: #81A1C1;">body</span> Count_Task <span style="color: #81A1C1;">is</span>
    Counter : Natural := 0;
<span style="color: #81A1C1;">begin</span>
</pre>
</div>

<p>
Apenas inicia, la tarea entra en un bucle hasta que todos los consumidores terminaron. El bucle consiste en:
</p>

<ol class="org-ol">
<li>Espera hasta que un consumidor emita el mensaje <code>Add_Consumer</code>.
</li>
<li>Cuando lo recibe, muestra en pantalla el Id del consumidor y suma uno al contador.
</li>
<li>Verifica si ya registro a todos los consumidores. Si es así, termina el bucle.
</li>
</ol>

<div class="org-src-container">

<pre class="src src-ada"><span style="color: #81A1C1;">loop</span>
    <span style="color: #81A1C1;">accept</span> Add_Consumer (Id : Integer) <span style="color: #81A1C1;">do</span>
        Put_Line (<span style="color: #A3BE8C;">"Counter&gt; Consumer "</span> &amp; Id'Image
                    &amp; <span style="color: #A3BE8C;">" registered."</span>);
        Counter := Counter + 1;
        Put_Line (<span style="color: #A3BE8C;">"Counter&gt; Number: "</span> &amp; Counter'Image
                    &amp; <span style="color: #A3BE8C;">"/"</span> &amp; Consumers_Count'Image);

    <span style="color: #81A1C1;">end</span> Add_Consumer;

    <span style="color: #81A1C1;">exit</span> <span style="color: #81A1C1;">when</span> Counter = Consumers_Count;
<span style="color: #81A1C1;">end</span> <span style="color: #81A1C1;">loop</span>;
</pre>
</div>

<p>
Finalmente, indica la cantidad de datos que restan consumir. Esto es útil para verificar si el algoritmo funcionó correctamente.
</p>

<div class="org-src-container">

<pre class="src src-ada">    Put_Line (<span style="color: #A3BE8C;">"Counter&gt; All consumer endings registered."</span>);
    Put_Line (<span style="color: #A3BE8C;">"Counter&gt; Data not consumed:"</span> &amp; Data.Length'Image);
<span style="color: #81A1C1;">end</span> Count_Task;
</pre>
</div>
</div>
</li>

<li><a id="sec-6-4-2-4-3" name="sec-6-4-2-4-3"></a>Tarea productor<br ><div class="outline-text-6" id="text-6-4-2-4-3">
<p>
El productor utilizará una variable local para mantener su identificador. Análogo al consumidor tendrá dos procedimientos locales: uno para mostrar un mensaje con su Id y otro para producir el dato.
</p>

<div class="org-src-container">

<pre class="src src-ada"><span style="color: #81A1C1;">task</span> <span style="color: #81A1C1;">body</span> Producer_Task <span style="color: #81A1C1;">is</span>
    Id : Integer;

    <span style="color: #81A1C1;">procedure</span> Show (S : String);
    <span style="color: #81A1C1;">procedure</span> Produce_Element;

    <span style="color: #81A1C1;">procedure</span> Produce_Element <span style="color: #81A1C1;">is</span>
    <span style="color: #81A1C1;">begin</span>
        Data.Append (Current_Element);
        Show (<span style="color: #A3BE8C;">"Produced element:"</span> &amp; Current_Element'Image);

        Current_Element := Current_Element - 1;
    <span style="color: #81A1C1;">end</span> Produce_Element;

    <span style="color: #81A1C1;">procedure</span> Show (S : String) <span style="color: #81A1C1;">is</span>
    <span style="color: #81A1C1;">begin</span>
        Set_Colour (Red);
        Put_Line (<span style="color: #A3BE8C;">"P"</span> &amp; Id'Image &amp; <span style="color: #A3BE8C;">"&gt; "</span> &amp; S);
        Default_Colour;
    <span style="color: #81A1C1;">end</span> Show;

<span style="color: #81A1C1;">begin</span>
</pre>
</div>

<p>
Al comenzar, la tarea se quedará esperando a su inicialización. Como el consumidor, al recibir el mensaje mostrará en pantalla que comienza su actividad.
</p>

<div class="org-src-container">

<pre class="src src-ada"><span style="color: #81A1C1;">accept</span> Initialize (The_Id : Integer) <span style="color: #81A1C1;">do</span>
    Id := The_Id;
    Show (<span style="color: #A3BE8C;">"Producer initialized."</span>);
<span style="color: #81A1C1;">end</span> Initialize;
</pre>
</div>

<p>
Luego, inicia el bucle. Primero, consultará si ya produjo lo necesario. Pero para ello, necesitará consultar la variable <code>Current_Element</code> y para evitar una condición de carrera utilizará el semáforo correspondiente.
</p>

<p>
Apenas detecta que ya no hay elementos que producir, libera el semáforo para evitar deadlock con los otros productores y sale del bucle.
</p>
<div class="org-src-container">

<pre class="src src-ada">Current_Element_Semaphore.Seize;

<span style="color: #81A1C1;">if</span> Current_Element &lt;= 0 <span style="color: #81A1C1;">then</span>
    Show (<span style="color: #A3BE8C;">"Exiting"</span>);
    Current_Element_Semaphore.Release;

    <span style="color: #616e88;">--  </span><span style="color: #616e88;">enough data produced! get out of the loop!</span>
    <span style="color: #81A1C1;">exit</span> <span style="color: #81A1C1;">when</span> Current_Element &lt;= 0;
<span style="color: #81A1C1;">end</span> <span style="color: #81A1C1;">if</span>;
</pre>
</div>

<p>
A continuación produce un elemento. El semáforo <code>Current_Element_Semaphore</code> está aún activo porque la variable <code>Current_Element</code> será consultada para producer el elemento. Esto evitará una condición de carrera entre productores.
</p>

<p>
Al terminar de producir, se libera el semáforo para <code>Data</code>. Como es un semáforo contador, la operación para liberar <code>Release</code> sumará uno al contador permitiendo a los consumidores continuar con su trabajo si el semáforo es mayor que cero (mientras que haya un elemento por consumir). Luego, se libera <code>Current_Element_Semaphore</code> para permitir a los productores y consumidores usar la variable correspondiente.
</p>

<div class="org-src-container">

<pre class="src src-ada">    Produce_Element;

    Data_Semaphore.Release;
    Current_Element_Semaphore.Release;
<span style="color: #81A1C1;">end</span> <span style="color: #81A1C1;">loop</span>;
</pre>
</div>

<p>
Cuando el productor sale del bucle, muestra en pantalla que finalizó y concluye su ejecución.
</p>

<div class="org-src-container">

<pre class="src src-ada">    Show (<span style="color: #A3BE8C;">"Producer ended."</span>);
<span style="color: #81A1C1;">end</span> Producer_Task;
</pre>
</div>
</div>
</li></ol>
</li>

<li><a id="sec-6-4-2-5" name="sec-6-4-2-5"></a>Programa principal<br ><div class="outline-text-5" id="text-6-4-2-5">
<p>
Los siguientes arreglos crearán y contendrán las tareas productoras y consumidoras. Se utilizará la variable <code>I</code> para brindar un identificador único a cada tarea.
</p>

<p>
Recordar que al comenzar el programa principal los hilos ya inician su ejecución, aunque estarán esperando recibir la entrada <code>Initialize</code>.
</p>

<div class="org-src-container">

<pre class="src src-ada">    Producers : <span style="color: #81A1C1;">array</span> (1 .. Producers_Count) <span style="color: #81A1C1;">of</span> Producer_Task;
    Consumers : <span style="color: #81A1C1;">array</span> (1 .. Consumers_Count) <span style="color: #81A1C1;">of</span> Consumer_Task;
    I : Integer := 0;
<span style="color: #81A1C1;">begin</span>
    Put_Line (<span style="color: #A3BE8C;">"Main thread"</span>);
</pre>
</div>

<p>
El programa principal le brindará el Id a productor primero, y luego a cada consumidor.
</p>

<div class="org-src-container">

<pre class="src src-ada"><span style="color: #81A1C1;">for</span> Producer <span style="color: #81A1C1;">of</span> Producers <span style="color: #81A1C1;">loop</span>
    Producer.Initialize (I);
    I := I + 1;
<span style="color: #81A1C1;">end</span> <span style="color: #81A1C1;">loop</span>;

<span style="color: #81A1C1;">for</span> Consumer <span style="color: #81A1C1;">of</span> Consumers <span style="color: #81A1C1;">loop</span>
    Consumer.Initialize (I);
    I := I + 1;
<span style="color: #81A1C1;">end</span> <span style="color: #81A1C1;">loop</span>;
</pre>
</div>

<p>
En este momento de la ejecución, los hilos ya están creando y consumiendo datos. En paralelo, el hilo principal se terminará. Pero, el programa no finaliza hasta que todos los hilos terminen.
</p>

<div class="org-src-container">

<pre class="src src-ada">    Put_Line (<span style="color: #A3BE8C;">"End of main thread"</span>);
<span style="color: #81A1C1;">end</span> Producer_Consumer_Semaphore;
</pre>
</div>
</div>
</li></ol>
</div>
</div>

<div id="outline-container-sec-6-5" class="outline-3">
<h3 id="sec-6-5"><span class="section-number-3">6.5</span> <span class="label label-primary TODO">TODO</span> Lectores-escritores</h3>
</div>

<div id="outline-container-sec-6-6" class="outline-3">
<h3 id="sec-6-6"><span class="section-number-3">6.6</span> <span class="label label-primary TODO">TODO</span> Cocinero-comensal</h3>
</div>

<div id="outline-container-sec-6-7" class="outline-3">
<h3 id="sec-6-7"><span class="section-number-3">6.7</span> Fumadores</h3>
<div class="outline-text-3" id="text-6-7">
<p>
Todos los fumadores tienen que entrar a la sala. Cada fumador tiene algún item para armar el cigarrillo. Al entrar a la sala, arma el cigarrillo y lo fuma. En la sala se incorpora un item necesario para armar el cigarrillo.
</p>

<ul class="org-ul">
<li>Objeto activos: Fumadores
</li>
<li>Objeto pasivo: Sala
</li>
</ul>

<p>
La sala es el monitor con métodos synchronized: <code>entrar_fumar(int ingredientes)</code>, <code>terminar_fumar()</code> y <code>colocar(int noesta)</code>. El último incorpora un ítem en la sala para que el fumador arme el cigarrillo.
</p>
</div>

<div id="outline-container-sec-6-7-1" class="outline-4">
<h4 id="sec-6-7-1"><span class="section-number-4">6.7.1</span> <span class="label label-primary TODO">TODO</span> Solución</h4>
</div>
</div>
</div>


<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> Hilos en los lenguajes de programación</h2>
<div class="outline-text-2" id="text-7">
</div><div id="outline-container-sec-7-1" class="outline-3">
<h3 id="sec-7-1"><span class="section-number-3">7.1</span> Ada</h3>
<div class="outline-text-3" id="text-7-1">
<p>
En Ada los hilos se denominan Tasks.
</p>

<ul class="org-ul">
<li><a href="https://en.wikibooks.org/wiki/Ada_Programming/Tasking#Selective_Wait">"Tasking" section on the WikiBook "Ada Programming".</a>
</li>
<li><a href="http://archive.adaic.com/docs/style-guide/83style/html/sty-06.html">Chapter 6 "Concurrency" at Ada 83 Quality and Style Guide</a>
</li>
<li><a href="https://www.adaic.org/resources/add_content/docs/95style/html/sec_6/toc.html">Chapter 6 "Concurrency" at Ada 95 Quality and Style Guide</a>
</li>
<li><a href="http://archive.adaic.com/standards/83lrm/html/lrm-09.html">Section 9 "Tasks" at Ada '83 Reference Manual</a>
</li>
<li><a href="http://www.ada-auth.org/standards/rm12_w_tc1/html/RM-9.html">Section 9 "Tasks and Synchronization" at Ada 2012 Reference Manual</a>
</li>
<li><a href="http://www.ada-auth.org/standards/rm12_w_tc1/html/RM-D.html">Annex D "Real-Time Systems" at Ada 2012 Reference Manual</a> (normative) 
La mayoría de las secciones de este anexo posee información acerca de prioridad, <i>dispatching model</i>, planificador, multiprocesamiento, <i>dispatching domain</i> para multiprocesadores, etc.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-7-2" class="outline-3">
<h3 id="sec-7-2"><span class="section-number-3">7.2</span> Python</h3>
<div class="outline-text-3" id="text-7-2">
</div>

<div id="outline-container-sec-7-2-1" class="outline-4">
<h4 id="sec-7-2-1"><span class="section-number-4">7.2.1</span> Threads</h4>
<div class="outline-text-4" id="text-7-2-1">
<ul class="org-ul">
<li><a href="https://docs.python.org/3/tutorial/stdlib2.html#multi-threading">https://docs.python.org/3/tutorial/stdlib2.html#multi-threading</a>
</li>
<li>threading module:
</li>
</ul>
<p>
<a href="https://docs.python.org/3/library/threading.html#module-threading">https://docs.python.org/3/library/threading.html#module-threading</a>
</p>
<ul class="org-ul">
<li><a href="http://rosettacode.org/wiki/Dining_philosophers#Python">http://rosettacode.org/wiki/Dining_philosophers#Python</a>
</li>
<li>Reader-writer problem:
</li>
</ul>
<p>
<a href="http://rosettacode.org/wiki/Synchronous_concurrency#Python">http://rosettacode.org/wiki/Synchronous_concurrency#Python</a>
</p>
<ul class="org-ul">
<li>Queues to simplify thread creation and processing:
</li>
</ul>
<p>
<a href="https://docs.python.org/3/library/queue.html#module-queue">https://docs.python.org/3/library/queue.html#module-queue</a>
</p>
</div>
</div>

<div id="outline-container-sec-7-2-2" class="outline-4">
<h4 id="sec-7-2-2"><span class="section-number-4">7.2.2</span> Coroutines and tasks</h4>
<div class="outline-text-4" id="text-7-2-2">
<ul class="org-ul">
<li><a href="https://docs.python.org/3/library/asyncio-task.html?highlight=coroutine">https://docs.python.org/3/library/asyncio-task.html?highlight=coroutine</a>
</li>
<li>asyncio module that implements the <code>async</code> and <code>await</code>. <a href="https://docs.python.org/3/library/asyncio.html?highlight=asyncio#module-asyncio">https://docs.python.org/3/library/asyncio.html?highlight=asyncio#module-asyncio</a>
</li>
<li>The <code>async def</code> returns a Coroutine object: <a href="https://docs.python.org/3/c-api/coro.html?highlight=coroutine">https://docs.python.org/3/c-api/coro.html?highlight=coroutine</a>
</li>
<li><a href="https://docs.python.org/3/reference/compound_stmts.html#async-def">https://docs.python.org/3/reference/compound_stmts.html#async-def</a>
</li>
<li>PEP-0492 that proposes the Coroutine. <a href="https://www.python.org/dev/peps/pep-0492/">https://www.python.org/dev/peps/pep-0492/</a>
</li>
</ul>
</div>
</div>
</div>
</div>
</div></div></div>
<footer id="postamble" class="">
<div><p class="date">Fecha: 16 oct 2020</p>
<p class="author">Autor: Christian Gimenez</p>
<p class="date">Created: 2020-11-04 mié 12:05</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 27.1 (<a href="http://orgmode.org">Org-mode</a> 9.3.6)</p>
</div>
</footer>
</body>
</html>
